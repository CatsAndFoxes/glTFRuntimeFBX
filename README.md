# FBX Loader for glTFRuntime

This is an extension for glTFRuntime allowing the load of FBX assets.

![HeatFBX](https://github.com/rdeioris/glTFRuntimeFBX/assets/2234592/ba4ec16f-f5b7-4f31-8136-c5ad16ddab08)

Currently the following features are supported:

* Static Meshes
* Hierarchies
* Skeletal Meshes with unlimited influences
* Morph Targets
* Skeletal Animations (with or without Mesh specified in the asset)
* MorphTarget Animations
* Vertex Colors
* PBR Material (still far from perfect)

Work in progress:

* LOD Groups
* Cameras
* Lights
* Async functions
* Improved material handling
* Raw curves extraction
* Animation retargeting
* Load StaticMeshes as Skeletal (for supporting MorphTargets without a Skeleton)

This plugin makes use of the amazing ufbx (https://github.com/ufbx/ufbx) library for the parsing.

## Usage

The easiest way is to use the provided Actor, ```glTFRuntimeFBXAssetActor``` that contains the logic for building a scene by iterating the nodes as well as playing animations.

The Actor expects a glTFRuntimeAsset as input. Those objects can be generated by the various glTFRuntime loaders (File, URLs, strings, commands, clipboard...) but requires the 'Blob' mode (that disables the GLTF parsing):

![image](https://github.com/rdeioris/glTFRuntimeFBX/assets/2234592/740944ae-df2b-4221-8421-5cf2523e599f)

As with other glTFRuntime extensions, the loaders can process FBX files compressed as gzip, lz4 or as zip archives (generally the most common way if you want to bundle the external textures in a single file).

Currently loading textures from external files is not supported for security reasons (The FBX format has a weird/risky way of dealing with textures paths...)

Once you have the glTFRuntimeAsset object, you can pass it to a standard Spawn Actor From Class node (or the World->SpawnActor C++ method):

![image](https://github.com/rdeioris/glTFRuntimeFBX/assets/2234592/1fd957de-f119-475d-8110-de77cd0abb48)

## Functions

For more advanced users lower-level functions as provided in a Blueprint Function Library: ```UglTFRuntimeFBXFunctionLibrary```

The glTFRuntimeFBXAssetActor uses those functions to implement its whole logic.

There are two main 'Objects' (well, actually they are Structs) to deal with:

* FBXNode (FglTFRuntimeFBXNode): represents a node in the FBX asset, it is the basic block for the hiearchy (nodes can be plain transforms/locators, meshes, skeletons, cameras, lights...)
* FBXAnim (FglTFRuntimeFBXAnim): represents an animation, multiple animations can be exposed in the same asset

```cpp
static FglTFRuntimeFBXNode GetFBXRootNode(UglTFRuntimeAsset* Asset);
```

```cpp
static TArray<FglTFRuntimeFBXNode> GetFBXNodes(UglTFRuntimeAsset* Asset);
```

```cpp
static TArray<FglTFRuntimeFBXNode> GetFBXNodeChildren(UglTFRuntimeAsset* Asset, const FglTFRuntimeFBXNode& FBXNode);
```

```cpp
static TArray<FglTFRuntimeFBXAnim> GetFBXAnimations(UglTFRuntimeAsset* Asset);
```

```cpp
static bool GetFBXDefaultAnimation(UglTFRuntimeAsset* Asset, FglTFRuntimeFBXAnim& FBXAnim);
```

```cpp
static bool IsFBXNodeBone(UglTFRuntimeAsset* Asset, const FglTFRuntimeFBXNode& FBXNode);
```

```cpp
static bool LoadFBXAsRuntimeLODByNode(UglTFRuntimeAsset* Asset, const FglTFRuntimeFBXNode& FBXNode, FglTFRuntimeMeshLOD& RuntimeLOD, const FglTFRuntimeMaterialsConfig& StaticMeshMaterialsConfig, const FglTFRuntimeMaterialsConfig& SkeletalMeshMaterialsConfig);
```

```cpp
static UAnimSequence* LoadFBXAnimAsSkeletalMeshAnimation(UglTFRuntimeAsset* Asset, const FglTFRuntimeFBXAnim& FBXAnim, const FglTFRuntimeFBXNode& FBXNode, USkeletalMesh* SkeletalMesh, const FglTFRuntimeSkeletalAnimationConfig& SkeletalAnimationConfig);
```

```cpp
static UAnimSequence* LoadFBXExternalAnimAsSkeletalMeshAnimation(UglTFRuntimeAsset* Asset, const FglTFRuntimeFBXAnim& FBXAnim, USkeletalMesh* SkeletalMesh, const FglTFRuntimeSkeletalAnimationConfig& SkeletalAnimationConfig);
```

## Materials handling
